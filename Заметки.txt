Русские треки не скробблились из-за того, что в строке:
byte[] EncodedPostParams = Encoding.UTF8.GetBytes(submissionReq); была ASCII кодировка
 
Нельзя в имени трека и исполнителя писать &. Это нарушает структуру get запроса. Видимо, нужно писать код этого символа (урл кодирование поможет).

Правильный порядок индексов при мультиотправке.
int[] t = { 0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1, 20, 2, 3, 4, 5, 6, 7, 8, 9};
Параметры должны идти не a[0]...m[0]&a[1], a a[0]&a[1]...m[0]&m[1]. 

При добавлении новых песен он берёт альбом, продолжительности и т.д. с твоего запроса, то есть при скробблинге уже существующих можно не париться (главное, исполнитель и название трека). Числовые поля лучше всё-таки заполнять хоть чем-то, ибо сервер может не воспринять песню. Но лучше 1 раз песню добавлять с правильной продолжительностью из другого места. Так что лучше отсюда добавлять только те песни, которые уже есть в библиотеке, чтобы не создавать кривые второстепенные данные (альбом, продолжительность и т.д. :))

Сигнатура делается отдельно для каждого(!) апи-метода и в ней параметры располагаются имязначение в альфа-порядке

Мясо:


/*
string ziga = MD5("api_key"+ApiKey+"artist[0]prodigymethodtrack.scrobblesk"+sessK+"timestamp[0]"+timestamp+"track[0]smack"+mySecret);
                string sf = "method=track.scrobble&sk=" + sessK + "&api_key=" + ApiKey + "&artist[0]=prodigy&track[0]=smack&timestamp[0]=" + timestamp + "&api_sig=" + ziga;
                string temp3 = "method=track.scrobble&track[0]=Rocket&artist[0]=Defueppard&timestamp[0]=" + (timestamp - 300).ToString() + "&track[1]=Women&artist[1]=DefLeppard&timestamp[1]=" + timestamp.ToString() + "&api_key=" + ApiKey + "&api_sig=" + ziga + "&sk=" + sessK;
 рабочие строки для нового АПИ
 
 * api_keyea13f7fe78f7ef62bbbc5c43dcd6dfcbartist[0]Example Artistmethodtrack.scrobbleskf448e2ecfb287a466162b24efdf588ectimestamp[0]1298908503track[0]Example Trackaeaa72cd88242eb7f1437ed8b9937e16"
 
 method=track.scrobble&sk=f448e2ecfb287a466162b24efdf588ec&api_key=ea13f7fe78f7ef62bbbc5c43dcd6dfcb&artist[0]=Example Artist&timestamp[0]=1298908803&track[0]=Example Track&api_sig=141694047efdb18d29916b6bc4bf0b39
 
 */

// не совпадение сигнатуры и отправки из-за таймстампа!
// string submissionReq = "s=" + sessID + "&a[0]=" + artist + "&a[1]=Disturbed&t[0]=" + track + "&t[1]=Session&i[0]=" + timestamp + "&i[1]=" + (timestamp+300) + "&o[0]=P&o[1]=P&r[0]=L&r[1]=L&l[0]=300&l[1]=300&b[0]=" + String.Empty + "&b[1]=" + String.Empty + "&n[0]=1&n[1]=1&m[0]=" + String.Empty + "&m[1]=" + String.Empty;


#region Мясо
/*
void ScrobbleOneTrack(string login, string password, string artist, string track, int time)
        {
            
            string client_id = "tst"; // для тестовых клиентов используется этот идентификатор
            string client_ver = "1.0";
            string auth = MD5(MD5(password) + time);//токен авторизации, который равен md5(md5(пароль) + timestamp)
            string handshakeReq = "http://post.audioscrobbler.com/?hs=true&p=1.2.1&c=" + client_id + "&v= " + client_ver + "&u=" + login + "&t=" + time + "&a=" + auth;// + pre); // создаём с адресом в параметрах.

            HttpWebRequest handshakerequest = (HttpWebRequest)WebRequest.Create(handshakeReq);
            handshakerequest.UserAgent = "Mozilla/5.0"; // 
            handshakerequest.AllowAutoRedirect = true; // допустимо ли перенаправление
            HttpWebResponse handshakeResponse = (HttpWebResponse)handshakerequest.GetResponse(); // получение ответа от сервераа
            string handshakeResult = new StreamReader(handshakeResponse.GetResponseStream(),
                                           Encoding.UTF8).ReadToEnd(); // чтение потока (поток ответа, кодировка).чтение потока до конца.
            ///////////////////////////////////

            // Формируем строку с параметрами
            // выбираем вторую строку с айди сессии
            string sessID = String.Empty;
            int d = 0;
            for (int i = 0; i < handshakeResult.Length; i++)
            {
                if (handshakeResult[i] == '\n')
                {
                    d++;
                    continue;
                }
                if (d > 1) break;
                if (d == 1) sessID += handshakeResult[i];
            }

            string submissionReq = "s=" + HttpUtility.UrlEncode(sessID) + "&a[0]=" + HttpUtility.UrlEncode(artist) + "&t[0]=" + HttpUtility.UrlEncode(track) + "&i[0]=" + HttpUtility.UrlEncode(time.ToString()) + "&o[0]=P&r[0]=L&l[0]=300&b[0]=" + String.Empty + "&n[0]=1&m[0]=" + String.Empty;//&a[1]=" + HttpUtility.UrlEncode("Uknown") + "&t[1]=" + HttpUtility.UrlEncode("1213") + "&i[1]=" + HttpUtility.UrlEncode("455465") + "&o[1]=P&r[1]=L&l[1]=120&b[1]=\"\"&n[1]=\"\"&m[1]=\"\"";

            HttpWebRequest submissionRequest = (HttpWebRequest)WebRequest.Create("http://post2.audioscrobbler.com:80/protocol_1.2"); // адрес запроса (без параметров)

            // Настраиваем параметры запроса
            submissionRequest.UserAgent = "Mozilla/5.0";
            submissionRequest.Method = "POST"; // Указываем метод отправки данных скрипту, в случае с Post обязательно

            
            submissionRequest.AllowAutoRedirect = true;
            // request.Referer = mainSiteUrl;
            // request.CookieContainer = cookieCont;

            // Указываем тип отправляемых данных
            submissionRequest.ContentType = "application/x-www-form-urlencoded"; // основная строчка из-за которой не работало! (точнее, из-за того, что она была закомменчена). В случае с Post обязательна, видимо из-за её отсутствия неправильно кодировались данные

            // Преобразуем данные к соответствующую кодировку
            byte[] EncodedPostParams = Encoding.UTF8.GetBytes(submissionReq); // получение массива байтов из строки с параметрами
            submissionRequest.ContentLength = EncodedPostParams.Length;

            // Записываем данные в поток
            submissionRequest.GetRequestStream().Write(EncodedPostParams,
                                             0,
                                             EncodedPostParams.Length); // запись в поток запроса (массив байтов, хз, сколько запиливаем)

            submissionRequest.GetRequestStream().Close();

            // Получаем ответ
            HttpWebResponse submissionResponse = (HttpWebResponse)submissionRequest.GetResponse(); // получаем ответ

            // Получаем html-код страницы
            string submissionResult = new StreamReader(submissionResponse.GetResponseStream(),
                                           Encoding.UTF8).ReadToEnd(); // считываем поток ответа
           
            if (!submissionResult.Contains("OK")) // проверяет, содержит ли строка эту подстроку, с учётом регистра
                throw new Exception("Треки не отправлены!");
        }
 */

/*
 try
                {
                    pBMain.Visible = true;
                    double i = 0;
                    // установка сеанса работы с сервером
                    TimeSpan rtime = DateTime.Now - (new DateTime(1970, 1, 1, 0, 0, 0));
                    TimeSpan t1 = new TimeSpan(3, 0, 0);
                    rtime -= t1; // вычитаем три часа, чтобы не было несоответствия из-за разницы в часовых поясах
                    int timestamp = (int)rtime.TotalSeconds; // общее количество секунд
                    foreach (object t in lbList.Items)
                    {
                        Song tmp = (Song)t;
                        ScrobbleOneTrack(tbLogin.Text, tbPassword.Text, tmp.Artist, tmp.Track, timestamp);
                        timestamp -= 300;
                        i++;
                        pBMain.Value = (int)((i / lbList.Items.Count) * 100);
                        Thread.Sleep(500);
                    }
                }
                catch (Exception e1)
                {
                    MessageBox.Show(e1.Message, String.Empty, MessageBoxButtons.OK, MessageBoxIcon.Error);
                    pBMain.Visible = false;
                    pBMain.Value = 0;
                    return;
                }
                // если метод не завершить принудительно, всё, что после catch - сработает
 */

//        private void btnTest_Click(object sender, EventArgs e)
//        {
//            TimeSpan w = DateTime.Now - (new DateTime(1970, 1, 1, 0, 0, 0));
//            TimeSpan t1 = new TimeSpan(3,0,0);
//            w -= t1;
//            int t = (int)w.TotalSeconds;
//            string client_id = "tst";
//            string client_ver = "1.0";
//            string user = "v_decadence";
//            string timestamp = t.ToString();

//            string auth = MD5(MD5("fuckINbitch") + timestamp);//"";//токен авторизации который равен md5(md5(пароль) + timestamp)
//            string req = "http://post.audioscrobbler.com/?hs=true&p=1.2.1&c=" + client_id + "&v= " + client_ver + "&u=" + user + "&t=" + timestamp + "&a=" + auth;// + pre); // создаём с адресом в параметрах.
//            //HttpWebRequest fr = (HttpWebRequest)WebRequest.Create("http://www.google.com/");
//            // пример получения исходного кода страницы через запрос
//            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(req);


//            request.UserAgent = "Mozilla/5.0"; // 
//            request.AllowAutoRedirect = true; // допустимо ли перенаправление
//            // request.Referer = "http://ffdr.ru/"; // адрес с которого мы якобы пришли на запрашиваемую страницу
//            HttpWebResponse response = (HttpWebResponse)request.GetResponse(); // получение ответа от сервераа

//            string html = new StreamReader(response.GetResponseStream(),
//                                           Encoding.UTF8).ReadToEnd(); // чтение потока (поток ответа, кодировка).чтение потока до конца.
//            MessageBox.Show(html);


//            ///////////////////////////////////

//            // Формируем строку с параметрами

//            // выбираем вторую строку с айди сессии
//            string tmp = String.Empty;
//            int d = 0;
//            for (int i = 0; i < html.Length; i++)
//            {
//                if (html[i] == '\n')
//                {
//                    d++;
//                    continue;

//                }

//                if (d > 1) break;
//                if (d == 1) tmp += html[i];
//            }
//            string sessId = tmp;
//            string artist = "yuy";
//            string track = "s12";

//            //  string req2 = "";
//            //  for (int i = 0; i < 2; i++)
//            // {
//            //    req


//            // }
//            // string req2 = "s=" + HttpUtility.UrlEncode(sessId) + "&a[0]=" + HttpUtility.UrlEncode(artist) + "&t[0]=" + HttpUtility.UrlEncode(track) + "&i[0]=" + HttpUtility.UrlEncode(timestamp);
//            string req2 = "s=" + HttpUtility.UrlEncode(sessId) + "&a[0]=" + HttpUtility.UrlEncode(artist) + "&t[0]=" + HttpUtility.UrlEncode(track) + "&i[0]=" + HttpUtility.UrlEncode(timestamp) + "&o[0]=P&r[0]=L&l[0]=120&b[0]=\"\"&n[0]=\"\"&m[0]=\"\"&a[1]=" + HttpUtility.UrlEncode("Uknown") + "&t[1]=" + HttpUtility.UrlEncode("1213") + "&i[1]=" + HttpUtility.UrlEncode("455465") + "&o[1]=P&r[1]=L&l[1]=120&b[1]=\"\"&n[1]=\"\"&m[1]=\"\"";

//            //  string req2 = "s=" + HttpUtility.UrlEncode(sessId) + "&a[0]=" + HttpUtility.UrlEncode(artist) + "&t[0]=" + HttpUtility.UrlEncode(track) + "&i[0]=" + HttpUtility.UrlEncode(timestamp);
//            // string req2 = "s=" + sessId + "&a[0]=" + artist + "&a[1]=df&t[0]=" + track + "&t[1]=sdfsd&i[0]=" + timestamp + "&i[1]=" + timestamp + "&o[0]=P&o[1]=P&r[0]=L&r[1]=L&l[0]=120&l[1]&b[0]=''&b[1]=''&n[0]=''&n[1]=''&m[0]=''&m[1]=''";



//            /*
//             r[0]=<rating>
//A single character denoting the rating of the track. Empty if not applicable. 
//L
//Love (on any mode if the user has manually loved the track). This implies a listen.
//B
//Ban (only if source=L). This implies a skip, and the client should skip to the next track when a ban happens.
//S
//Skip (only if source=L)

//Note: Currently a Last.fm web service must also be called to set love (track.love) or ban (track.ban) status. We anticipate that the next version of the scrobble protocol will no longer perform love and ban and this will instead be handled by the web services only.
//l[0]=<secs>
//The length of the track in seconds. Required when the source is P, optional otherwise.
//b[0]=<album>
//The album title, or an empty string if not known.
//n[0]=<tracknumber>
//The position of the track on the album, or an empty string if not known.
//m[0]=<mb-trackid>
//The MusicBrainz Track ID, or an empty string if not known.
//             */
//            HttpWebRequest request1 = (HttpWebRequest)WebRequest.Create("http://post2.audioscrobbler.com:80/protocol_1.2"); // адрес запроса (без параметров)

//            // Настраиваем параметры запроса
//            request1.UserAgent = "Mozilla/5.0";
//            request1.Method = "POST"; // в случае с Post обязательно

//            // Указываем метод отправки данных скрипту
//            request1.AllowAutoRedirect = true;
//            // request.Referer = mainSiteUrl;
//            // request.CookieContainer = cookieCont;

//            // Указываем тип отправляемых данных
//            request1.ContentType = "application/x-www-form-urlencoded"; // основная строчка из-за которой не работало! (точнее, из-за того, что она была закомменчена)

//            // Преобразуем данные к соответствующую кодировку
//            byte[] EncodedPostParams = Encoding.ASCII.GetBytes(req2); // получение массива байтов из строки с параметрами
//            request1.ContentLength = EncodedPostParams.Length;

//            // Записываем данные в поток
//            request1.GetRequestStream().Write(EncodedPostParams,
//                                             0,
//                                             EncodedPostParams.Length); // запись в поток запроса (массив байтов, хз, сколько запиливаем)

//            request1.GetRequestStream().Close();

//            // Получаем ответ
//            HttpWebResponse response1 = (HttpWebResponse)request1.GetResponse(); // получаем ответ

//            // Получаем html-код страницы
//            string html1 = new StreamReader(response1.GetResponseStream(),
//                                           Encoding.UTF8).ReadToEnd(); // считываем поток ответа
//            MessageBox.Show(html1);
//        }






#endregion